# -*- coding: utf-8 -*-
"""link_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IIFt6cEjWyDwP-SC2ivKdlR1lx0hCIH3

# Assignment 2 : link_prediction

## Download Package
"""

"""## Import Package"""

import torch
import torch.nn as nn
from torch.nn import Linear
from torch_geometric.nn import GCNConv
import csv
import numpy as np

"""## dataset """
d = 2
train1_path = f"dataset{d}/train.csv"
test1_path = f"dataset{d}/test.csv"
content_path = f"dataset{d}/content.csv"
epocht= 6000

from pathlib import Path
import pandas as pd 

class load_data(): 
  def __init__(self, path, attr_path):
    super(load_data,self).__init__()    
    self.path = path
    self.attr_path = attr_path

  def read_data(self):
      file = pd.read_csv(self.path)
      label = file.loc[:,'label'].values
      bilabel = []
      bilabel.extend(label)
      bilabel.extend(label)
      bilabel= np.array(bilabel)
      edgeto = file.loc[:,'to'].values
      edgefrom = file.loc[:,'from'].values

      edge_index = [[],[]]
      pos_edge_index = [[],[]]
      non_zero = np.nonzero(np.array(label))[0]
      edge_index[0].extend(edgeto)
      edge_index[1].extend(edgefrom)
      edge_index[1].extend(edgeto)
      edge_index[0].extend(edgefrom)
      edge_index = torch.tensor(edge_index)
      # positive
      pos_edge_index[0].extend(edgeto[non_zero])
      pos_edge_index[1].extend(edgefrom[non_zero])
      pos_edge_index[1].extend(edgeto[non_zero])
      pos_edge_index[0].extend(edgefrom[non_zero])
      pos_edge_index = torch.tensor(pos_edge_index)
      return edge_index, pos_edge_index, bilabel


  def read_content(self):
      attribution = []; node=[]
      content = pd.read_csv(self.attr_path,delimiter='\t',header=None)
      contentArray = content.values
      attribute = contentArray[contentArray[:, 0].argsort()]
      for i in attribute:
        n = i[0]
        x = i[1:]
        attribution.append(x)
        node.append(n)
      attribution = torch.tensor(attribution, dtype= torch.float)
      node_num = np.shape(node)[0]
      return attribution, node_num

"""# Model"""

from torch_geometric.nn import GCNConv

class Net(torch.nn.Module):
    def __init__(self, in_channels, hidden_channels, out_channels):
        super().__init__()
        self.conv1 = GCNConv(in_channels, hidden_channels)
        self.conv2 = GCNConv(hidden_channels, out_channels)


    def encode(self, x, edge_index):
        x = self.conv1(x, edge_index).relu()
        return self.conv2(x, edge_index)

    def decode(self, z, edge_label_index):
        # cosine similarity
        return (z[edge_label_index[0]] * z[edge_label_index[1]]).sum(dim = -1)

    def decode_all(self, z):
        prob_adj = z @ z.t()
        return (prob_adj > 0).nonzero(as_tuple = False).t()

from torch_geometric.data import Data


Dt = load_data(train1_path,content_path)
edge_index, pos_edge,  label = Dt.read_data()
attribution, node_num = Dt.read_content()

data = Data(x=attribution, edge_index = edge_index, pos_edge_index=pos_edge, y =label, num_nodes = node_num )
print(data)

attr = data.x
in_channel = np.shape(attr[0])[0]
model = Net(in_channel, 128, 1)

optimizer = torch.optim.Adam(params = model.parameters(), lr=0.001, weight_decay=5e-4)
# optimizer = torch.optim.Adam(params = model.parameters(), lr=0.001)
criterion = torch.nn.BCEWithLogitsLoss()

import wandb 
from sklearn.metrics import f1_score

total_examples = total_loss = 0
def train():

    threshold = torch.tensor([0.4])
    min_valid_loss = 1
    model.train()
    for epoch in range(epocht):
          optimizer.zero_grad()
          z = model.encode(data.x, data.pos_edge_index)
          out = model.decode(z, data.edge_index).view(-1)
          s_predict = out.sigmoid()
          loss = criterion(out, torch.FloatTensor(data.y))
          predicted = (s_predict > threshold).float()
          f1score = f1_score(predicted.detach().numpy(), data.y.astype(float))
          loss.backward()
          optimizer.step()
          if epoch % 100 == 0:
            print(f'epoch: {epoch} / training loss: {loss} /  f1score {f1score}')
            if min_valid_loss > loss:
              min_valid_loss = loss
            # Saving State Dict
              torch.save(model.state_dict(), 'saved_model.pth')

train()
