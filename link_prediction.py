# -*- coding: utf-8 -*-
"""link_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IIFt6cEjWyDwP-SC2ivKdlR1lx0hCIH3

# Assignment 2 : link_prediction

## Download Package
"""

"""## Import Package"""

import torch
import torch.nn as nn
from torch.nn import Linear
from torch_geometric.nn import GCNConv
import csv
import numpy as np
import pprint

"""## dataset """

from pathlib import Path
import pandas as pd 

class load_data(): 
  def __init__(self, path):
    super(load_data,self).__init__()    
    self.data = {}
    self.path = path

  def read_data(self):
      file = pd.read_csv(self.path)
      label = file.loc[:,'label'].values
      bilabel = []
      bilabel.extend(label)
      bilabel.extend(label)
      bilabel= np.array(bilabel)
      edg_id = file.loc[:,'id'].values
      edgeto = file.loc[:,'to'].values
      edgefrom = file.loc[:,'from'].values

      edge_index = [[],[]]; pos_edge_index = [[],[]]
      non_zero = np.nonzero(np.array(label))[0]
      edge_index[0].extend(edgeto)
      edge_index[1].extend(edgefrom)
      edge_index[1].extend(edgeto)
      edge_index[0].extend(edgefrom)
      edge_index = torch.tensor(edge_index)
      # positive
      pos_edge_index[0].extend(edgeto[non_zero])
      pos_edge_index[1].extend(edgefrom[non_zero])
      pos_edge_index[1].extend(edgeto[non_zero])
      pos_edge_index[0].extend(edgefrom[non_zero])
      pos_edge_index = torch.tensor(pos_edge_index)

      return edge_index, pos_edge_index, bilabel,edg_id


  def read_content(self):
      attribution = []; node=[]
      content = pd.read_csv(self.path,delimiter='\t',header=None)
      contentArray = content.values
      attribute = contentArray[contentArray[:, 0].argsort()]
      for i in attribute:
        n = i[0]      
        x = i[1:]
        attribution.append(x)
        node.append(n)
      attribution = torch.tensor(attribution, dtype= torch.float)
      node_num = np.shape(node)[0]
      return attribution, node_num

"""# Model"""

from torch_geometric.nn import GCNConv

class Net(torch.nn.Module):
    def __init__(self, in_channels, hidden_channels, out_channels):
        super().__init__()
        self.conv1 = GCNConv(in_channels, hidden_channels)
        self.conv2 = GCNConv(hidden_channels, out_channels)


    def encode(self, x, edge_index):
        x = self.conv1(x, edge_index).relu()
        return self.conv2(x, edge_index)

    def decode(self, z, edge_label_index):
        # cosine similarity
        return (z[edge_label_index[0]] * z[edge_label_index[1]]).sum(dim = -1)

    def decode_all(self, z):
        prob_adj = z @ z.t()
        return (prob_adj > 0).nonzero(as_tuple = False).t()

from torch_geometric.data import Data

import os
d = 3
train1_path = f"dataset{d}/train.csv"
test1_path = f"dataset{d}/test.csv"
content_path = f"dataset{d}/content.csv"

Dt = load_data(train1_path)
edge_index, pos_edge,  label,edg_id = Dt.read_data()
D = load_data(content_path)
attribution, node_num = D.read_content()

data = Data(x=attribution, edge_index = edge_index, pos_edge_index=pos_edge, y =label, num_nodes = node_num ,edg_id=edg_id)


attr = data.x

in_channel = np.shape(attr[0])[0]
# attr.shape
model = Net(in_channel, 128, 1)
# print(model)
# optimizer = torch.optim.Adam(params = model.parameters(), lr=0.001, weight_decay=5e-4)
optimizer = torch.optim.Adam(params = model.parameters(), lr=0.00001)

criterion = torch.nn.BCEWithLogitsLoss()

import wandb 
from sklearn.metrics import f1_score

total_examples = total_loss = 0
def train():
    epocht= 7000
    threshold = torch.tensor([0.4])
    min_valid_loss = 1
    model.train()
    for epoch in range(epocht):
      optimizer.zero_grad()
      z = model.encode(data.x, data.pos_edge_index)
      out = model.decode(z, data.edge_index).view(-1)
      s_predict = out.sigmoid()
      loss = criterion(out, torch.FloatTensor(data.y))
      predicted = (s_predict > threshold).float()
      f1score = f1_score(predicted.detach().numpy(), data.y.astype(float))
      loss.backward()
      optimizer.step()
      if epoch % 100 == 0:
        print(f'epoch: {epoch} / training loss: {loss} /  f1score {f1score}')
        if min_valid_loss > loss:
          # print("loss min")
          min_valid_loss = loss
        # Saving State Dict
          torch.save(model.state_dict(), 'saved_model.pth')

train()
